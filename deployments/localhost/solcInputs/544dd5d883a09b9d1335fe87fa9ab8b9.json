{
  "language": "Solidity",
  "sources": {
    "contracts/RainbowToken.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\n\ncontract RainbowToken is Context {\n    struct Color {\n        uint8 r;\n        uint8 g;\n        uint8 b;\n    }\n\n    struct Player {\n        Color originalColor;\n        Color color;\n        uint256 blendingPrice;\n    }\n\n    uint256 public constant DEFAULT_BLENDING_PRICE = 0.1 ether;\n    uint256 public constant SELF_BLEND_PRICE = 0.5 ether;\n    uint256 public constant ENTRY_FEE = 0.1 ether;\n\n    Color private _targetColor;\n\n    mapping(address => Player) private _players;\n\n    error InvalidTargetColor(uint8 r, uint8 g, uint8 b);\n    error SenderAlreadyPlayer(address account);\n    error InsufficientValue(uint256 value);\n    error SenderNotAPlayer(address account);\n    error BlendingAccountNotAPlayer(address blendingAccount);\n    error InvalidZeroBlendingPrice();\n    error ColorNotMatching(Color blendingColor, Color actualColor);\n    error PlayerNotWinner(address account);\n    error EtherTransferFail(address recipient);\n\n    event PlayerJoined(address indexed account, Color originalColor);\n    event BlendingPriceUpdated(address indexed account, uint256 blendingPrice);\n    event SelfBlended(address indexed account, Color color);\n    event Blended(\n        address indexed account,\n        address indexed blendingAccount,\n        Color color,\n        Color blendingColor\n    );\n    event GameOver(address indexed winner, uint256 amount);\n\n    constructor(\n        uint8 r,\n        uint8 g,\n        uint8 b\n    ) {\n        if (r <= 5 || r >= 250 || g <= 5 || g >= 250 || b <= 5 || b >= 250)\n            revert InvalidTargetColor(r, g, b);\n        _targetColor = Color({r: r, g: g, b: b});\n    }\n\n    modifier onlyPlayer() {\n        if (!_isPlayer(_msgSender())) revert SenderNotAPlayer(_msgSender());\n        _;\n    }\n\n    function joinGame() public payable {\n        if (_isPlayer(_msgSender())) revert SenderAlreadyPlayer(_msgSender());\n        if (msg.value < ENTRY_FEE) revert InsufficientValue(msg.value);\n\n        Color memory originalColor = _generateOriginalColor();\n\n        _players[_msgSender()] = Player({\n            originalColor: originalColor,\n            color: originalColor,\n            blendingPrice: DEFAULT_BLENDING_PRICE\n        });\n\n        emit PlayerJoined(_msgSender(), originalColor);\n    }\n\n    function updateBlendingPrice(uint256 blendingPrice) public onlyPlayer {\n        if (blendingPrice == 0) revert InvalidZeroBlendingPrice();\n        _players[_msgSender()].blendingPrice = blendingPrice;\n        emit BlendingPriceUpdated(_msgSender(), blendingPrice);\n    }\n\n    function selfBlend() public payable onlyPlayer {\n        if (msg.value < SELF_BLEND_PRICE) revert InsufficientValue(msg.value);\n        Player storage _player = _players[_msgSender()];\n        _blend(_player.color, _player.originalColor);\n        emit SelfBlended(_msgSender(), _player.color);\n    }\n\n    function blend(address blendingAccount, Color calldata blendingColor)\n        public\n        payable\n        onlyPlayer\n    {\n        if (!_isPlayer(blendingAccount))\n            revert BlendingAccountNotAPlayer(blendingAccount);\n        Player memory otherPlayer = _players[blendingAccount];\n        if (msg.value < otherPlayer.blendingPrice)\n            revert InsufficientValue(msg.value);\n        if (\n            otherPlayer.color.r != blendingColor.r ||\n            otherPlayer.color.g != blendingColor.g ||\n            otherPlayer.color.b != blendingColor.b\n        ) revert ColorNotMatching(blendingColor, otherPlayer.color);\n\n        (bool sent, ) = blendingAccount.call{value: msg.value / 2}(\"\");\n        if (!sent) revert EtherTransferFail(blendingAccount);\n\n        Color storage _color = _players[_msgSender()].color;\n        _blend(_color, blendingColor);\n\n        emit Blended(_msgSender(), blendingAccount, _color, blendingColor);\n    }\n\n    function claimVictory() public onlyPlayer {\n        Color memory playerColor = _players[_msgSender()].color;\n\n        uint16 r = uint16(_absSub(playerColor.r, _targetColor.r));\n        uint16 g = uint16(_absSub(playerColor.g, _targetColor.g));\n        uint16 b = uint16(_absSub(playerColor.b, _targetColor.b));\n\n        if (r * r + g * g + b * b > 25) revert PlayerNotWinner(_msgSender());\n\n        emit GameOver(_msgSender(), address(this).balance);\n\n        selfdestruct(payable(_msgSender()));\n    }\n\n    function isPlayer(address account) public view returns (bool) {\n        return _isPlayer(account);\n    }\n\n    function getPlayer(address account) public view returns (Player memory) {\n        return _players[account];\n    }\n\n    function getTargetColor() public view returns (Color memory) {\n        return _targetColor;\n    }\n\n    function _absSub(uint8 a, uint8 b) internal pure returns (uint8) {\n        unchecked {\n            if (a > b) {\n                return a - b;\n            }\n            return b - a;\n        }\n    }\n\n    function _generateOriginalColor() internal view returns (Color memory) {\n        uint256 defaultColorSeed = uint256(\n            keccak256(\n                abi.encodePacked(\n                    _msgSender(),\n                    blockhash(block.number - 1),\n                    block.timestamp\n                )\n            )\n        );\n\n        Color memory color = Color({\n            r: _toPrimary(uint8((defaultColorSeed & 0xff0000) / 0xffff)),\n            g: _toPrimary(uint8((defaultColorSeed & 0xff00) / 0xff)),\n            b: _toPrimary(uint8(defaultColorSeed & 0xff))\n        });\n\n        return color;\n    }\n\n    function _toPrimary(uint8 colorComponent) internal pure returns (uint8) {\n        if (colorComponent > 127) {\n            return 255;\n        } else {\n            return 0;\n        }\n    }\n\n    function _isPlayer(address account) internal view returns (bool) {\n        return _players[account].blendingPrice > 0;\n    }\n\n    function _blend(Color storage _color, Color memory blendingColor) internal {\n        _color.r = uint8((uint16(_color.r) + uint16(blendingColor.r)) / 2);\n        _color.g = uint8((uint16(_color.g) + uint16(blendingColor.g)) / 2);\n        _color.b = uint8((uint16(_color.b) + uint16(blendingColor.b)) / 2);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}